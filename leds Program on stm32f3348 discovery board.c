/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define   __vo            volatile
#define   uint32          unsigned int
#define RCC_Base                 0x40021000U

#define PERIPH_BASEADDR          0x40000000U
#define APB1PERIPH_BASEADDR      PERIPH_BASEADDR
#define APB2PERIPH_BASEADDR      0x40010000U
#define AHB1PERIPH_BASEADDR      0x40020000U
#define AHB2PERIPH_BASEADDR      0x48000000U
#define AHB3PERIPH_BASEADDR      0x50000000U


//GPIO pins Address defination

#define GPIOA_BASEADDR          (AHB2PERIPH_BASEADDR)
#define GPIOB_BASEADDR          (AHB2PERIPH_BASEADDR+0x400U)
#define GPIOC_BASEADDR          (AHB2PERIPH_BASEADDR+0x800U)
#define GPIOD_BASEADDR          (AHB2PERIPH_BASEADDR+0xC00U)
#define GPIOF_BASEADDR          (AHB2PERIPH_BASEADDR+0x1400U)
#define RCC_BASEADDR            (AHB1PERIPH_BASEADDR+0x1000U)

// struct for GPIO  refernce manual search for GPIO register map
typedef struct
{
    __vo unsigned int MODER;
    __vo unsigned int OTYPER;
    __vo unsigned int OSPEEDR;
    __vo unsigned int PUPDR;
    __vo unsigned int IDR;
    __vo unsigned int ODR;
    __vo unsigned int BSRR;
    __vo unsigned int LCKR;
    __vo unsigned int AFR[2];
    __vo unsigned int BRR;
}GPIO_regDef;


// struct for RCC  refernce manual search for GPIO register map
typedef struct
{
    __vo unsigned int CR;
    __vo unsigned int CFGR;
    __vo unsigned int CIR;
    __vo unsigned int APB2RSTR;
    __vo unsigned int APB1RSTR;
    __vo unsigned int AHBENR;
    __vo unsigned int APB2ENR;
    __vo unsigned int APB1ENR;
    __vo unsigned int BDCR;
    __vo unsigned int CSR;
    __vo unsigned int AHBRSTR;
    __vo unsigned int CFGR2;
    __vo unsigned int CFGR3;
}RCC_regDef;
#define RCC ((RCC_regDef*) RCC_BASEADDR)
#define GPIOB ((GPIO_regDef*) GPIOB_BASEADDR)
#define GPIOC ((GPIO_regDef*) GPIOC_BASEADDR)

void GPIO_Init(void) {
    // Step 1: Enable GPIOB clock
    RCC->AHBENR |= (1 << 18); // Enable clock for GPIOB (Bit 18)

    // Step 2: Set PB6, PB7, PB8, PB9 as output
    GPIOB->MODER &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear mode bits
    GPIOB->MODER |= ( (1 << (8 * 2)) | (1 << (9 * 2)));  // Set to output mode (01)

    // Step 3: Configure output type as push-pull
    GPIOB->OTYPER &= ~((1 << 6) | (1 << 7) | (1 << 8) | (1 << 9)); // Set to push-pull (0)

    // Step 4: Set output speed to low (optional for stability)
    GPIOB->OSPEEDR &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear speed bits
    GPIOB->OSPEEDR |= ((1 << (6 * 2)) | (1 << (7 * 2)) | (1 << (8 * 2)) | (1 << (9 * 2)));  // Set to low speed (01)

    // Step 5: Configure pull-up/pull-down as no-pull
    GPIOB->PUPDR &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear PUPD bits (no pull-up, no pull-down)

    // Step 6: Set PB6, PB7, PB8, PB9 high using BSRR
    GPIOB->BSRR = ((1 << 6) | (1 << 7) | (1 << 8) | (1 << 9)); // Set pins high
    GPIOC->MODER &= ~((3 << (9 * 2))); // Clear mode bits
    GPIOC->MODER |= (1 << (9 * 2));  // Set to output mode (01)
    GPIOC->BSRR = (1 << 9);
}
void delay(int j){
	for(int i=0;i<j;i++)
	{

	}
}


int main(void)
{
    GPIO_Init();  // Initialize GPIOB pins
    int num=300000;
    // Loop forever
    for(;;)
    {
    	GPIOB->MODER &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear mode bits
    	delay(num);
    	GPIOB->MODER |= ( (1 << (6 * 2)));  // Set to output mode (01)
    	delay(num);
    	GPIOB->MODER &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear mode bits
    	GPIOB->MODER |= ( (1 << (8 * 2)));  // Set to output mode (01)
    	delay(num);
    	GPIOB->MODER &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear mode bits
    	GPIOB->MODER |= ( (1 << (7 * 2)));  // Set to output mode (01)
    	delay(num);
    	GPIOB->MODER &= ~((3 << (6 * 2)) | (3 << (7 * 2)) | (3 << (8 * 2)) | (3 << (9 * 2))); // Clear mode bits
    	GPIOB->MODER |= ( (1 << (9 * 2)));  // Set to output mode (01)
    	delay(num);
    	if(num>5000)
    		num/=2;
    	else
    		num=300000;
    }
}
